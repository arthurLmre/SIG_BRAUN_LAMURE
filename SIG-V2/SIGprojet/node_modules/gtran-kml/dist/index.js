"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

require("babel-polyfill");

var util = require("util");
var fs = require("fs");
var tokml = require("tokml");
var et = require("elementtree");
var md5 = require("md5");
var config = require("config");

require("util.promisify").shim();

var symbol = require("./symbol.js");
var readFileAsync = util.promisify(fs.readFile);
var writeFileAsync = util.promisify(fs.writeFile);

// just to provide backwards compatibility
exports.setPromiseLib = function () {};

exports.toGeoJson = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(fileName) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var encoding, data, etree, geojson, schemas, placemarks;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (fs.statSync(fileName)) {
              _context.next = 2;
              break;
            }

            throw new Error("Give KML file does not exist.");

          case 2:
            encoding = options.encoding || "utf-8";
            _context.next = 5;
            return readFileAsync(fileName, encoding);

          case 5:
            data = _context.sent;
            etree = et.parse(data), geojson = {
              type: "FeatureCollection",
              features: []
            };
            schemas = findSchemas(etree);
            placemarks = etree.findall(".//Placemark");

            placemarks.forEach(function (placemark) {
              geojson.features.push({
                type: "feature",
                geometry: getGeometry(placemark),
                properties: getProperties(placemark, schemas)
              });
            });

            return _context.abrupt("return", geojson);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function (_x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.fromGeoJson = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(geojson, fileName) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var symbols, kmlContent, geomType, fileNameWithExt;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            geojson = JSON.parse(JSON.stringify(geojson));

            symbols = {};


            if (typeof options.symbol === "function") {
              geojson.features.forEach(function (feature) {
                var symbol = options.symbol(feature);
                var id = md5(JSON.stringify(symbol));

                if (!symbols[id]) {
                  symbols[id] = symbol;
                }

                feature.properties[config.DEFAULT_STYLE_ID] = id;
              });
            } else if (_typeof(options.symbol) === "object") {
              symbols[config.DEFAULT_STYLE_ID] = options.symbol;
            }

            kmlContent = tokml(geojson, {
              name: options.name || "name"
            });


            if (options.symbol) {
              geomType = getGeomType(geojson);

              kmlContent = symbol.addTo(kmlContent, geomType, symbols);
            }

            if (!fileName) {
              _context2.next = 13;
              break;
            }

            fileNameWithExt = fileName;

            if (fileNameWithExt.indexOf(".kml") === -1) {
              fileNameWithExt += ".kml";
            }

            _context2.next = 10;
            return writeFileAsync(fileNameWithExt, kmlContent);

          case 10:
            return _context2.abrupt("return", fileNameWithExt);

          case 13:
            return _context2.abrupt("return", {
              data: kmlContent,
              format: "kml"
            });

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  }));

  return function (_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();

function getGeomType(geojson) {
  // Assume there is only one geometry type in the geojson
  switch (geojson.features[0].geometry.type) {
    case "Point":
    case "Polygon":
    case "LineString":
      return geojson.features[0].geometry.type;
    default:
      throw new Error("Geometry type unsupported.");
  }
}

function getGeometry(placemark) {
  var geomTag = placemark.find("./Point");
  if (geomTag) {
    return createGeometry("Point", geomTag.findtext("./coordinates"));
  }

  geomTag = placemark.find("./LineString");
  if (geomTag) {
    return createGeometry("LineString", geomTag.findtext("./coordinates"));
  }

  geomTag = placemark.find("./Polygon");
  if (geomTag) {
    var outRingCoors = geomTag.findtext("./outerBoundaryIs/LinearRing/coordinates");

    var inRingsCoors = [];
    geomTag.findall("./innerBoundaryIs/LinearRing/coordinates").forEach(function (node) {
      inRingsCoors.push(node.text);
    });

    return createGeometry("Polygon", outRingCoors, inRingsCoors);
  }
}

function createGeometry(geomType, outerCoorStr, innerCoorStr) {
  return {
    type: geomType,
    coordinates: getCoordinates(outerCoorStr, innerCoorStr)
  };
}

function getCoordinates(outCoorsdStr, inCoordsStrs) {
  var pointStrs = outCoorsdStr.split(" ");

  if (pointStrs.length == 1) {
    var coors = pointStrs[0].split(",");
    return [parseFloat(coors[0]), parseFloat(coors[1])];
  } else {
    var outPoints = [];
    pointStrs.forEach(function (pointStr) {
      var coors = pointStr.split(",");
      outPoints.push([parseFloat(coors[0]), parseFloat(coors[1])]);
    });

    if (!inCoordsStrs) {
      return outPoints;
    }

    var allPoints = [outPoints];
    inCoordsStrs.forEach(function (coordsStr) {
      var inPoints = [],
          pointStrs = coordsStr.split(" ");

      pointStrs.forEach(function (coordsStr) {
        var coors = coordsStr.split(",");
        inPoints.push([parseFloat(coors[0]), parseFloat(coors[1])]);
      });

      allPoints.push(inPoints);
    });

    return allPoints;
  }
}

function findSchemas(rootnode) {
  var schemaNodes = rootnode.findall("./Document/Schema");

  // considering if we have more than one schema
  if (schemaNodes.length > 0) {
    var schemas = {};
    schemaNodes.forEach(function (schemaNode) {
      var schema = {};

      // get the type of field
      schemaNode.findall("./SimpleField").forEach(function (fieldNode) {
        schema[fieldNode.attrib.name] = fieldNode.attrib.type;
      });

      schemas[schemaNode.attrib.id] = schema;
    });

    return schemas;
  }
}

function getProperties(placemark, schemas) {
  var properties = {};

  // name
  var name = placemark.findtext("./name");
  if (name) {
    properties.name = name;
  }

  // description
  var description = placemark.findtext("./description");
  if (description) {
    properties.description = description;
  }

  // schema data
  if (schemas) {
    var schemaDatasets = placemark.findall("./ExtendedData/SchemaData");
    schemaDatasets.forEach(function (schemaDataset) {
      var schema = schemas[schemaDataset.attrib.schemaUrl.replace("#", "")],
          fields = schemaDataset.findall("./SimpleData");
      fields.forEach(function (field) {
        properties[field.attrib.name] = convert(field.text, schema[field.attrib.name]);
      });
    });
  }

  // simple data
  var fields = placemark.findall("./ExtendedData/Data");
  fields.forEach(function (field) {
    properties[field.attrib.name] = field.findtext("./value");
  });

  return properties;
}

function convert(value, toType) {
  switch (toType) {
    case "int":
    case "uint":
    case "short":
    case "ushort":
      return parseInt(value);
    case "float":
    case "double":
      return parseFloat(value);
    case "bool":
      return value.toLowerCase() === "true";
    default:
      return value;
  }
}